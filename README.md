## Leetcode Notes

#### 066.加一
模拟，注意最后的进位

### 098.验证二叉树
中序遍历+单调性检查
常见错误： 只判断每个结点的值小于左孩子且大于右孩子

#### 035.搜索插入位置　
#### 069.X的平方根
#### 278.第一个错误的位置

不要问，问就是简单二分

#### 053.最大子序和
ans = max{f[i]}
f[i] = max{s[i] + f[i],s[i]}
分治也行233333333

#### 089.合并两个有序数组
mergesort 的merge操作
不过要从第一个数组最后开始，从小到大merge
可以节省空间

#### 101.对称二叉树
先检查根节点 为空 return true
不为空 继续判断左孩子和右孩子
对于左孩子和右孩子
如果这棵树是对称二叉树 应该满足三个条件
左右孩子相等
左孩子右子树和右孩子左子树相同
左孩子左子树和右孩子右子树相同

#### 102.二叉树层次遍历
用队列搞就行
注意不要push空节点
#### 104.二叉树最大深度

递归

#### 108.将有序数组转换为二叉搜索树

从数组最中间的元素建树
保持平衡

#### 121.买卖股票的最佳时机

ans = max(ans,price[i] - min_val[i - 1])
min_val[n] = min {a[0],a[1], ... ,a[n]}

#### 122.买卖股票的最佳时机II
水题
居然比Ｉ简单

#### 136.只出现一次的数字

利用位运算 xor计数


#### 198.打家劫舍

DP 
dp[i] = max(dp[i - 2] + nums[i],dp[i - 1])
预处理dp[0],dp[1]

